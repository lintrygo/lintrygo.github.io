<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="stay hungry stay foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="WuHao">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="WuHao">
<meta property="og:description" content="stay hungry stay foolish">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WuHao">
<meta name="twitter:description" content="stay hungry stay foolish">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WuHao</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WuHao</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/15/new对象过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/15/new对象过程/" class="post-title-link" itemprop="url">new对象过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 13:52:42" itemprop="dateCreated datePublished" datetime="2021-08-15T13:52:42+08:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-05 22:53:56" itemprop="dateModified" datetime="2022-09-05T22:53:56+08:00">2022-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>假设第一次使用该类，这样可分为两个过程: 加载并初始化类和创建对象</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>使用双亲委派机制。</p>
<p><strong>1. 加载</strong></p>
<p>由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例</p>
<p><strong>2. 验证</strong></p>
<p>格式验证：验证是否符合class文件规范</p>
<p>语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）</p>
<p>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等</p>
<p><strong>3. 准备</strong></p>
<p>准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量），并不是实例变量 分配内存并设置类变量初始值的阶段。在jdk8之后，类变量会随着Class对象一起存放在java堆中</p>
<p><strong>4. 解析</strong></p>
<p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p><strong>5. 初始化</strong></p>
<p>为静态变量赋值，执行static代码块等。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><strong>1. 在堆区分配对象需要的内存</strong></p>
<p>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</p>
<p><strong>2. 对所有实例变量赋默认值</strong></p>
<p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值</p>
<p><strong>3. 执行实例初始化代码</strong></p>
<p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p>
<p><strong>4. 如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</strong></p>
<p>需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/23/mysql执行计划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/mysql执行计划/" class="post-title-link" itemprop="url">mysql执行计划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 09:12:24" itemprop="dateCreated datePublished" datetime="2021-04-23T09:12:24+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-05 22:59:02" itemprop="dateModified" datetime="2022-09-05T22:59:02+08:00">2022-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MYSQL/" itemprop="url" rel="index"><span itemprop="name">MYSQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql执行计划"><a href="#mysql执行计划" class="headerlink" title="mysql执行计划"></a>mysql执行计划</h1><p>​       在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p>
<p>​       可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p>
<p>​       官网地址： <a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a> </p>
<h3 id="1、执行计划中包含的信息"><a href="#1、执行计划中包含的信息" class="headerlink" title="1、执行计划中包含的信息"></a>1、执行计划中包含的信息</h3><table>
<thead>
<tr>
<th style="text-align:center">Column</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">The <code>SELECT</code> identifier</td>
</tr>
<tr>
<td style="text-align:center">select_type</td>
<td style="text-align:center">The <code>SELECT</code> type</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">The table for the output row</td>
</tr>
<tr>
<td style="text-align:center">partitions</td>
<td style="text-align:center">The matching partitions</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">The join type</td>
</tr>
<tr>
<td style="text-align:center">possible_keys</td>
<td style="text-align:center">The possible indexes to choose</td>
</tr>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">The index actually chosen</td>
</tr>
<tr>
<td style="text-align:center">key_len</td>
<td style="text-align:center">The length of the chosen key</td>
</tr>
<tr>
<td style="text-align:center">ref</td>
<td style="text-align:center">The columns compared to the index</td>
</tr>
<tr>
<td style="text-align:center">rows</td>
<td style="text-align:center">Estimate of rows to be examined</td>
</tr>
<tr>
<td style="text-align:center">filtered</td>
<td style="text-align:center">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td style="text-align:center">extra</td>
<td style="text-align:center">Additional information</td>
</tr>
</tbody>
</table>
<p><strong>id</strong></p>
<p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p>
<p>id号分为三种情况：</p>
<p>​        1、如果id相同，那么执行顺序从上到下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure>
<p>​        2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure>
<p>​        3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>select_type</strong></p>
<p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p>
<table>
<thead>
<tr>
<th style="text-align:center"><code>select_type</code> Value</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIMPLE</td>
<td style="text-align:center">Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td style="text-align:center">PRIMARY</td>
<td style="text-align:center">Outermost SELECT</td>
</tr>
<tr>
<td style="text-align:center">UNION</td>
<td style="text-align:center">Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td style="text-align:center">DEPENDENT UNION</td>
<td style="text-align:center">Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td style="text-align:center">UNION RESULT</td>
<td style="text-align:center">Result of a UNION.</td>
</tr>
<tr>
<td style="text-align:center">SUBQUERY</td>
<td style="text-align:center">First SELECT in subquery</td>
</tr>
<tr>
<td style="text-align:center">DEPENDENT SUBQUERY</td>
<td style="text-align:center">First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td style="text-align:center">DERIVED</td>
<td style="text-align:center">Derived table</td>
</tr>
<tr>
<td style="text-align:center">UNCACHEABLE SUBQUERY</td>
<td style="text-align:center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td style="text-align:center">UNCACHEABLE UNION</td>
<td style="text-align:center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody>
</table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure>
<p><strong>table</strong></p>
<p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<br>        1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p>
<p>​        2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</p>
<p>​        3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</p>
<p><strong>type</strong></p>
<p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p>
<p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure>
<p> <strong>possible_keys</strong> </p>
<p>​        显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>key</strong></p>
<p>​        实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>key_len</strong></p>
<p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>ref</strong></p>
<p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>rows</strong></p>
<p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p><strong>extra</strong></p>
<p>包含额外的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/mysql缓存池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/mysql缓存池/" class="post-title-link" itemprop="url">mysql缓存池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-21 20:15:52" itemprop="dateCreated datePublished" datetime="2021-03-21T20:15:52+08:00">2021-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-05 22:57:46" itemprop="dateModified" datetime="2022-09-05T22:57:46+08:00">2022-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MYSQL/" itemprop="url" rel="index"><span itemprop="name">MYSQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>mysql中的重要组件buffer pool(缓存池)，为避免低效率频繁的IO操作，在内存中开辟一块空间为缓存池（默认设置128M，innodb_buffer_pool_size设置）,MYSQL相关操作先与缓存池交互。</p>
<h2 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h2><p>buffer pool缓存页的大小和磁盘页的大小是一致的，都是16kb。</p>
<p>为了更好的管理这些在缓冲池中的缓存页，InnoDB为每一个缓存页都创建了一些所谓的控制信息。<br>这些控制信息包括该页所属的表空间编号、页号、缓存页在缓冲池中的地址、链表节点信息、一些锁信息。</p>
<h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>mysql服务器系统启动后，首先申请Buffer Pool内存，然后将内存划分为若干个控制信息块和内存块，此时每个块尚未进行缓存数据，此时需要进行管理这些块，把所有的空闲的块通过链表关联到一起，这个链表称为 free链表（和STL中 内存池申请内存后使用链表管理方式类似），每一个缓存页对应的控制信息块都加入了这个链表中。</p>
<p> 链表进行管理这些空闲块，那么关于链表的信息也需要进行存储，Innodb中，特意定义了一个称为 基节点 ，包含链表的头和尾以及节点个数信息。基节点所占有的内存不属于Buffer Pool中的，而是单独申请的一块内存，占用40字节的内存。</p>
<p>有了free链表之后，当磁盘中读取数据后，从free链表中获取一个空闲的块缓存数据，并将此块从free链表中移除，表示缓存已经被使用（读STL内存分配也是如此操作）。</p>
<h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><p>如果修改了某个缓存页的数据，那么就会和磁盘上数据保持不一致，此时这个缓存页被称为脏页（dirty page）， 最简单的方式是如果出现脏页，那么立即同步到磁盘，频繁往写数据会严重影响程序的性能，so每次出现脏页，并不着急立即同步到磁盘，在后面某个节点进行同步（后详细叙述）；对于在缓存中出现的N多个脏页也需要我们进行管理，不然后面进行同步的时候找不到该同步哪些页，每次出现数据更新，成为脏页后这个页会被添加到一个flush链表中，flush链表构造和free链表差不多，也有个基节点保存链表信息：头节点，尾节点，个数等。</p>
<h3 id="lru链表"><a href="#lru链表" class="headerlink" title="lru链表"></a>lru链表</h3><p>基于LRU算法(Least Recently Used)最近最少使用。</p>
<ol>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p><strong>全表扫描</strong></p>
<p>当出现全表扫描时，InnoDB 会将该表的数据页全部从磁盘文件加载进缓存页中，这些缓存页会被加入到 LRU 链表中；这有可能导致需要淘汰许多频繁使用的缓存页。</p>
<p><strong>预读</strong></p>
<p>预读是 InnoDB 引擎的一个优化机制，当你从磁盘上读取某个数据页，InnoDB 可能会将与这个数据页相邻的其他数据页也读取到 Buffer Pool 中。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><strong>冷热分离</strong></p>
<p>对数据进行冷热分离，将 LRU 链表分成两部分，一部分用来存放冷数据，也就是刚从磁盘读进来的数据，另一部分用来存放热点数据，也就是经常被访问到数据。</p>
<p>存放冷数据的区域占这个 LRU 链表的多少呢？这由参数 「innodb_old_blocks_pct」 控制，默认是 37%（约八分之三）。</p>
<p>当从磁盘读取数据页后，会先将数据页存放到 LRU 链表冷数据区的头部，如果这些缓存页在 1 秒之后被访问，那么就将缓存页移动到热数据区的头部；如果是 1 秒之内被访问，则不会移动，缓存页仍然处于冷数据区中。1 秒这个数值，是由参数 innodb_old_blocks_time 控制。</p>
<p><strong>冷热分离其他优化</strong></p>
<p>当一个缓存页处于热数据区域的时候，我们去访问这个缓存页，这个时候我们真的有必要把它移动到热点数据区域的头部吗？</p>
<p>从代码的角度来看，将链表中的数据移动到头部，实际上就是修改元素的指针指向，这个操作是非常快的。但是为了安全起见，在修改链表的时候，我们需要对链表加上锁，否则容易出现并发问题。</p>
<p>当并发量大的时候，因为要加锁，会存在锁竞争，每次移动显然效率就会下降。因此 MySQL 针对这一点又做了优化，如果一个缓存页处于热数据区域，且在热数据区域的前 1/4 区域（注意是热数据区域的 1/4，不是整个链表的 1/4），那么当访问这个缓存页的时候，就不用把它移动到热数据区域的头部；如果缓存页处于热数据的后 3/4 区域，那么当访问这个缓存页的时候，会把它移动到热数据区域的头部。</p>
<h2 id="生产调优"><a href="#生产调优" class="headerlink" title="生产调优"></a>生产调优</h2><ol>
<li><p>根据服务器配置，修改Buffer Pool 大小(避免频繁IO)</p>
</li>
<li><p>修改Buffer Pool 实例个数。（为了提高并发度，减少锁的竞争）</p>
</li>
<li><p>根据相关命令查询MYSQL状态信息（show engine innodb status;），判断冷数据区移动热数据区的频率，修改热数据区的比例（innodb_old_blocks_pct）</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/01/垃圾回收算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/垃圾回收算法/" class="post-title-link" itemprop="url">垃圾回收算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 22:48:28" itemprop="dateCreated datePublished" datetime="2020-09-01T22:48:28+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-05 22:53:47" itemprop="dateModified" datetime="2022-09-05T22:53:47+08:00">2022-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是垃圾</p>
<p>垃圾是指在运行程序中没有任何指针指向的对象,这个对象就是需要被回收的垃圾</p>
<p>如果不及时对内存中的垃圾及时清理,那么这个垃圾对象所占用的内存空间会一直保留到应用程序结束,被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>对于一个对象,只要有任何一个对象引用了A,则A的引用计数器就加1;当引用失效时,引用计数器就减1。只要对象A的引用计数器的值为0,即表示对象A不可能再被使用,可进行回收</p>
<p>优点:实现简单,垃圾对象便于表示;判定效率高,回收没有延迟行性。</p>
<p>缺点:</p>
<ul>
<li>需要单独的字段存储计数器,这样的做法增加了存储的开销</li>
<li>每次赋值都需要更新计数器,伴随着加法和减法的操作,这增加了时间开销</li>
<li>引用计数器有一个严重的问题,即无法处理循环引用的情况。这是一条致命缺陷,导致在java的垃圾回收器中没有使用这类算法。会存在内存泄漏问题。</li>
</ul>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>基本思路</p>
<ul>
<li>可达性分析算法是以根对象集合(GCRoots)为起始点,按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</li>
<li>使用可达性分析算法后,内存中存活的对象都会被根对象集合直接或间接连接着,搜索所走过的路劲称为引用链</li>
<li>如果目标对象没有任何引用链相连,则是不可达,意味着该对象已经死亡,可以标记为死亡对象</li>
<li>在可达性分析算法中,只有能被根对象集合直接或间接连接的对象才是存活对象</li>
</ul>
<p>GC Roots包括以下几类元素</p>
<ul>
<li>虚拟机栈引用的对象(比如各个线程被调用的方法中使用的参数,局部变量等)</li>
<li>本地方法栈内JNI(通常说的本地方法)引用的对象</li>
<li>方法区中类静态属性所引用的对象</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>JAVA虚拟机内部的引用</li>
<li>反映java虚拟机内部情况的JMXBean,JVMTI中注册的回调,本地代码缓存等</li>
</ul>
<p>小技巧</p>
<ul>
<li>由于Root采用栈方式存放变量和指针,所以如果一个指针,它保存了堆内存里面的对象,但是自己又不存放堆内存里面,那它就是一个Root</li>
</ul>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>当垃圾回收器发现没有引用指向一个对象,即:垃圾回收此对象之前,总会先调用这个对象的finalize()方法</p>
<h2 id="GC-Root-分析工具"><a href="#GC-Root-分析工具" class="headerlink" title="GC Root 分析工具"></a>GC Root 分析工具</h2><p>先把生成程序dump文件,具体分析工具有Jprofiler,MAT</p>
<h3 id="dump文件生成"><a href="#dump文件生成" class="headerlink" title="dump文件生成"></a>dump文件生成</h3><p>JVM生成dump文件一般有两种方式</p>
<p>一、 出现OOM时自动生成堆dump<br>JVM启动命令增加两个参数:<br>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=/home/app/dumps/</p>
<p>二、人工通过执行指令，直接生成当前JVM的dump文件<br>例如：<br>jmap -dump:format=b,file=/home/app/testdump.hprof 6218<br>其中6218是JVM的当前进程号</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为:</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有==CMS收集器==会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。</li>
</ul>
<p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p>
<h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h3><p>标记: Collector从引用根节点开始遍历,标记为所有被引用的对象。一般是在对象的Header中记录为可达对象</p>
<p>清除: Collector对堆内存从头到尾进行线性的遍历,如果发现某个对象在其Header中没有标记为可达对象,则将其回收</p>
<p>缺点:</p>
<ul>
<li>效率不算高(递归方式遍历)</li>
<li>在进行GC的时候,需要停止整个应用程序,导致用户体验差</li>
<li>这种方式清理出来的空闲内存是不连续的,产生内存碎片。需要维护一个空闲列表</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将活着的内存空间分位两块,每次只使用其中一块,在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中,之后清除正在使用内存块中的所有对象,交换两个内存的角色,最后完成垃圾回收。</p>
<p>优点:</p>
<ul>
<li>没有标记和清除过程,实现简单,运行高效</li>
<li>复制过去以后保证空间的连续性,不会出现碎片问题</li>
</ul>
<p>缺点:</p>
<ul>
<li>此算法的缺点也是很明显的,就是需要两倍的空间内存。</li>
<li>对于G1这种拆分为大量region的GC,复制而不是移动,意味着GC需要维护region之间对象引用关系,不管内存占用或者时间开销也不小</li>
</ul>
<p>适合垃圾对象很多,存活对象很少的场景;例如:新生代中的Survior0和Surivor1</p>
<h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>第一阶段和标记清除算法一样,从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端,按顺序排放。之后,清理边界外所有的空间.</p>
<p>优点:</p>
<ul>
<li>消除了标记-清除算法当中,内存区域分散的缺点,我们需要给新对象分配内存是,JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中,内存减半的高额代价</li>
</ul>
<p>缺点:</p>
<ul>
<li>从效率上来说,标记-整理算法要低于复制算法</li>
<li>移动对象的同事,如果对象被其他对象引用,则还需要调整引用的地址</li>
<li>移动过程中,需要全程暂停用户应用程序。即:STW</li>
</ul>
<p>总结<br><img src="https://note.youdao.com/yws/res/12279/3AC623A68E1C4E1CB8D7FEF3D1158ADA" alt="image"></p>
<h3 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h3><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>提醒jvm垃圾回收器执行gc,但是不确定是否马上执行gc</p>
<p>System.runFinalization();</p>
<h3 id="内存泄漏举例"><a href="#内存泄漏举例" class="headerlink" title="内存泄漏举例"></a>内存泄漏举例</h3><p>单例模式</p>
<p>一些提供close的资源未关闭导致内存泄漏</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>强引用</li>
</ul>
<p>强引用所指向的对象在任何时候都不会被系统回收,虚拟机宁愿抛出OOM异常,也不会回收强引用所指向对象。可能导致内存泄漏</p>
<ul>
<li>软引用</li>
</ul>
<p>软引用是用来描述一些还有用,但非必需的对象。只被软引用关联着的对象,在系统将要发生内存溢出异常前,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存,才会抛出内存溢出异常。</p>
<p>通常用来实现内存敏感的缓存。比如:高速缓存</p>
<p>SoftReference<object> sf = new SoftReference<object>(obj)</object></object></p>
<ul>
<li>弱引用</li>
</ul>
<p>在系统GC时,只要发现弱引用,不管系统堆空间使用是否充足,都会回收掉只被弱引用关联的对象</p>
<p>WeakReference<object> sf = new WeakReference<object>(obj)</object></object></p>
<p>弱引用对象与软引用对象最大的不同就在于,当GC在进行回收时,需要通过算法检查是否回收软引用对象,而对于弱引用对象,GC总是回收。弱引用对象更容易更快被GC回收。</p>
<p><strong>ThreadLocal 中 ThreadLocalMap的key使用弱引用</strong></p>
<ul>
<li>虚引用</li>
</ul>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如能在这个对象被收集器回收时收到一个系统通知。</p>
<p>DirectBuffer(直接内存)有用到</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/数据结构-排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/05/数据结构-排序算法/" class="post-title-link" itemprop="url">数据结构-排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-05 20:00:05" itemprop="dateCreated datePublished" datetime="2018-11-05T20:00:05+08:00">2018-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-23 19:32:40" itemprop="dateModified" datetime="2020-08-23T19:32:40+08:00">2020-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><ul>
<li>插入排序（直接插入；折半插入；希尔插入）</li>
<li>选择排序（简单选择排序；堆排序）</li>
<li>交换排序 (冒泡排序；快速排序)</li>
<li>归并排序</li>
<li>基数排序</li>
<li>外部排序</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>两两比较相邻元素，每趟冒泡的结果是把序列中的最大元素放到了序列中的最终位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] array)&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    for (int i = 0; i &lt; array.length ; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; array.length-1-i ; j++) &#123;</span><br><span class="line">            if(array[j]&lt;array[j+1])&#123;</span><br><span class="line">                temp = array[j];</span><br><span class="line">                array[j] =  array[j+1];</span><br><span class="line">                array[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是冒泡排序的一种改进。基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，已达到整个序列变成有序序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] array,int low,int high)&#123;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            int index = getIndex(array,low,high);</span><br><span class="line">            quickSort(array,low,index-1);</span><br><span class="line">            quickSort(array,index+1,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getIndex(int[] array,int low,int high)&#123;</span><br><span class="line">        int temp = array[low];</span><br><span class="line">        while (low&lt;high)&#123;</span><br><span class="line"></span><br><span class="line">            while(low&lt;high &amp;&amp; array[high]&gt;temp)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[low] = array[high];</span><br><span class="line">            while (low&lt;high &amp;&amp; array[low]&lt;temp)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            array[high] = array[low];</span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = temp;</span><br><span class="line">        return  low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>基本思想：每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void insertSort(int[] array)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        for (int i = 1; i &lt;array.length ; i++) &#123;</span><br><span class="line">            int temp = array[i];</span><br><span class="line">            for (j = i-1; j&gt;=0 &amp;&amp; temp&lt;array[j] ; j--) &#123;</span><br><span class="line">                array[j+1] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j+1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>思想和直接插入类似，只是引入增量的概念，又称缩小增量排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] array)&#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(int gap = array.length/2;gap&gt;0;gap/=2)&#123;</span><br><span class="line">            for(int i = gap;i&lt;array.length;i++)&#123;</span><br><span class="line">                int temp = array[i];</span><br><span class="line">                for(j = i-gap;j&gt;=0&amp;&amp;temp&lt;array[j];j-=gap)&#123;</span><br><span class="line">                    array[j+gap] = array[j];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j+gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>假设排序表为L[1…n],第i趟排序即从L[i…n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确认一个元素的最终位置,这样经过n-1趟排序就可使整个排序表有序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] array)&#123;</span><br><span class="line">        int minValue;</span><br><span class="line">        int minIndex;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">            minIndex = i;</span><br><span class="line">            for (int j = i+1; j &lt;array.length ; j++) &#123;</span><br><span class="line">                if(minValue&gt;array[j])&#123;</span><br><span class="line">                    minValue = array[j];</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //交换最小值</span><br><span class="line">            if(minValue!=array[i])&#123;</span><br><span class="line">                array[minIndex] = array[i];</span><br><span class="line">                array[i] = minValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>采用分治的思想，分成一些小问题递归求解。将数组元素一个个分成独立元素，再两两合并，以此类推得到完整的有序序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public void mergeSortTest()&#123;</span><br><span class="line">        int[] array = &#123;10,9,8,7,6,5&#125;;</span><br><span class="line">        int[] temp = new int[array.length];</span><br><span class="line">        mergeSort(array,0,array.length-1,temp);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int[] array,int left,int right,int[] temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid = (left+right)/2;</span><br><span class="line">            mergeSort(array,left,mid,temp);</span><br><span class="line">            mergeSort(array,mid+1,right,temp);</span><br><span class="line">            merge(array,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void merge(int[] array,int left ,int mid,int right,int[] temp)&#123;</span><br><span class="line">        int i = left;</span><br><span class="line">        int j = mid+1;</span><br><span class="line">        int t = 0;</span><br><span class="line">        while (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            if(array[j]&lt;array[i])&#123;</span><br><span class="line">                temp[t] = array[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[t] = array[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (i&lt;=mid)&#123;</span><br><span class="line">            temp[t] = array[i];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (j&lt;=right)&#123;</span><br><span class="line">            temp[t] = array[j];</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //合并</span><br><span class="line">        t = 0 ;</span><br><span class="line">        while (left&lt;=right)&#123;</span><br><span class="line">            array[left] = array[t];</span><br><span class="line">            left++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void radixSortTest(int[] array)&#123;</span><br><span class="line">        //求最大值</span><br><span class="line">        int maxValue = array[0];</span><br><span class="line">        for(int value:array)&#123;</span><br><span class="line">            if(value&gt;maxValue)&#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //求最大值位数</span><br><span class="line">        int digit = (maxValue+&quot;&quot;).length();</span><br><span class="line"></span><br><span class="line">        //桶数量</span><br><span class="line">        int[][] buckets = new int[10][array.length];</span><br><span class="line">        //每个桶计数</span><br><span class="line">        int[] bucketNum  = new int[10];</span><br><span class="line">        for(int i = 0,n = 1;i&lt;digit;i++,n*=10)&#123;</span><br><span class="line">            //元素放入桶中</span><br><span class="line">            for(int j=0;j&lt;array.length;j++)&#123;</span><br><span class="line">                int digitValue = array[j]/n%10;</span><br><span class="line">                buckets[digitValue][bucketNum[digitValue]] = array[j];</span><br><span class="line">                bucketNum[digitValue]++;</span><br><span class="line">            &#125;</span><br><span class="line">            int index = 0;</span><br><span class="line">            //将元素放入回数组中</span><br><span class="line">            for (int k = 0; k &lt;bucketNum.length ; k++) &#123;</span><br><span class="line">                if(bucketNum[k]!=0)&#123;</span><br><span class="line">                    for(int l = 0;l&lt;bucketNum[k];l++)&#123;</span><br><span class="line">                        array[index++] = buckets[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bucketNum[k] = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h2><p><img src="/2018/11/05/数据结构-排序算法/sortIma.png" alt="image"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/08/过滤器ip白名单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/08/过滤器ip白名单/" class="post-title-link" itemprop="url">过滤器ip白名单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-08 22:18:08" itemprop="dateCreated datePublished" datetime="2018-10-08T22:18:08+08:00">2018-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-23 17:03:46" itemprop="dateModified" datetime="2020-08-23T17:03:46+08:00">2020-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Filter中注入Bean失败"><a href="#Filter中注入Bean失败" class="headerlink" title="Filter中注入Bean失败"></a>Filter中注入Bean失败</h2><p>在写这个过滤器的时候遇到个问题,Bean注入失败，为空，以前也没有注意到。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实Spring中，web应用启动的顺序是：listener-&gt;filter-&gt;servlet，先初始化listener，然后再来就filter的初始化，再接着才到我们的dispathServlet的初始化，因此，当我们需要在filter里注入一个注解的bean时，就会注入失败，因为filter初始化时，注解的bean还没初始化，没法注入。</p>
<h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>解决方式有好几种<br>我用的是手动getBean的方式<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac1 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc); </span><br><span class="line">ac1.getBean(&quot;beanId&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这里getBean内容注意大小写，经常因为没注意没获取到bean。</p>
<h2 id="获取登录ip"><a href="#获取登录ip" class="headerlink" title="获取登录ip"></a>获取登录ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 通过HttpServletRequest返回IP地址 </span><br><span class="line"> * @param request HttpServletRequest </span><br><span class="line"> * @return ip String </span><br><span class="line"> * @throws Exception </span><br><span class="line"> */  </span><br><span class="line">public String getIpAddr(HttpServletRequest request) throws Exception &#123;  </span><br><span class="line">    String ip = request.getHeader(&quot;x-forwarded-for&quot;);  </span><br><span class="line">    if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;  </span><br><span class="line">        ip = request.getHeader(&quot;Proxy-Client-IP&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;  </span><br><span class="line">        ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;  </span><br><span class="line">        ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;  </span><br><span class="line">        ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;  </span><br><span class="line">        ip = request.getRemoteAddr();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ip;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/05/jenkins初步使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/jenkins初步使用/" class="post-title-link" itemprop="url">jenkins初步使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 21:02:05" itemprop="dateCreated datePublished" datetime="2018-10-05T21:02:05+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-23 19:30:12" itemprop="dateModified" datetime="2020-08-23T19:30:12+08:00">2020-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="linux环境下安装jenkins"><a href="#linux环境下安装jenkins" class="headerlink" title="linux环境下安装jenkins"></a>linux环境下安装jenkins</h2><p>1.第一种是网上下载jenkins war包拷到/webapp目录下<br><br>2.第二种是在线安装,通过yum方式安装下载<br><br>sudo wget -O /etc/yum.repos.d/jenkins.repo <a href="http://pkg.jenkins-ci.org/redhat/jenkins.repo" target="_blank" rel="noopener">http://pkg.jenkins-ci.org/redhat/jenkins.repo</a><br><br>sudo rpm –import <a href="https://jenkins-ci.org/redhat/jenkins-ci.org.key" target="_blank" rel="noopener">https://jenkins-ci.org/redhat/jenkins-ci.org.key</a><br><br>sudo yum install jenkins<br></p>
<h2 id="启动jenkins"><a href="#启动jenkins" class="headerlink" title="启动jenkins"></a>启动jenkins</h2><p>service jenkins start<br></p>
<font color="Chocolate">注意:这里最好修改jenkins默认端口号8080，以防冲突</font><br><br>vi /etc/sysconfig/jenkins<br><br>查找/JENKINS_PORT，修改JENKINS_PORT=”8080”，默认为“8080”，我修改为了9999<br><br><br>## 访问jenkins<br>地址:<a href="http://ip:修改后的端口号" target="_blank" rel="noopener">http://ip:修改后的端口号</a><br><br>第一次登录是需要解锁，依据提示的路径,拷贝相应的密码到浏览器输入框。<br><br>之后提示安装自定义插件还是推荐插件，此处我选择推荐插件<br><br><font color="Chocolate">注意：这里，可能是由于网络的原因，我的一些插件迟迟下载不下来，页面卡死在下载插件那里，我就强制重启jenkins。ps -ef|grep jenkins,找出相应的jenklins进程，杀死进程：kill 进程号，之后重启jenkins,service jenkins start，重新访问，便可以进入到主界面，依据提示设置用户名密码那些。</font>

<p><img src="/2018/10/05/jenkins初步使用/jenkins.png" alt="image"></p>
<p>后续jenkins各项操作陆续更新。。。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/26/rabbitmq延迟队列简单运用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/26/rabbitmq延迟队列简单运用/" class="post-title-link" itemprop="url">rabbitmq延迟队列简单实用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-26 22:04:30" itemprop="dateCreated datePublished" datetime="2018-09-26T22:04:30+08:00">2018-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-23 17:03:46" itemprop="dateModified" datetime="2020-08-23T17:03:46+08:00">2020-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/中间件/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  &nbsp; &nbsp; &nbsp; &nbsp;之前也没有具体研究过rabbitmq延迟队列的实现，前段时间在写短信提醒用户支付订单这个需求的时候，发现了一些问题。现有的商城系统，订单取消定时器是5分钟跑一次，这样就造成了会有5分钟的时间误差，前端给用户的提示以及后续的操作都会有影响。而且这种定时器一直跑着还是挺消耗系统资源的，增加数据库压力<br>  &nbsp; &nbsp; &nbsp; &nbsp;然后也是一直查阅资料看看有什么更好的解决方案，看到这本《Rabbitmq实战指南》写还的挺好的，通俗易懂，里面也简单介绍了延迟队列。</p>
<hr>
<h2 id="什么是延迟队列"><a href="#什么是延迟队列" class="headerlink" title="什么是延迟队列"></a>什么是延迟队列</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;延迟队列存储的对象肯定是对应的延迟消息，所谓”延迟消息”是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。其实，AMQP协议，以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。</p>
<h2 id="过期时间TTL"><a href="#过期时间TTL" class="headerlink" title="过期时间TTL"></a>过期时间TTL</h2><p>TTL(Time To Live),即过期时间,RabbitMQ可以对消息和队列设置过期时间。<br><br>消息在队列中的生存时间一旦超过了设置的TTL值，就会变为死信。</p>
<h3 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte[] messageBodyBytes = &quot;Hello, world!&quot;.getBytes();</span><br><span class="line">AMQP.BasicProperties properties = new AMQP.BasicProperties();</span><br><span class="line">properties.setExpiration(&quot;60000&quot;);//设置消息的过期时间为60秒</span><br><span class="line">channel.basicPublish(&quot;my-exchange&quot;, &quot;routing-key&quot;, properties, messageBodyBytes);</span><br></pre></td></tr></table></figure>
<h3 id="设置队列的TTL"><a href="#设置队列的TTL" class="headerlink" title="设置队列的TTL"></a>设置队列的TTL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(&quot;x-expires&quot;, 1800000);</span><br><span class="line">channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);</span><br></pre></td></tr></table></figure>
<h2 id="DLX死信队列"><a href="#DLX死信队列" class="headerlink" title="DLX死信队列"></a>DLX死信队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dead Letter Exchanges,可以称为死信交换器</span><br><span class="line">channel.exchangeDeclare(&quot;exchange_delay_begin&quot;, &quot;direct&quot;, true);</span><br><span class="line">channel.exchangeDeclare(&quot;exchange_delay_done&quot;, &quot;direct&quot;, true);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(&quot;x-dead-letter-exchange&quot;, &quot;exchange_delay_done&quot;);</span><br><span class="line">channel.queueDeclare(&quot;queue_delay_begin&quot;, true, false, false, args);</span><br><span class="line">channel.queueDeclare(&quot;queue_delay_done&quot;, true, false, false, null);</span><br><span class="line"></span><br><span class="line">channel.queueBind(&quot;queue_delay_begin&quot;, &quot;exchange_delay_begin&quot;, &quot;delay&quot;);</span><br><span class="line">channel.queueBind(&quot;queue_delay_done&quot;, &quot;exchange_delay_done&quot;, &quot;delay&quot;);</span><br></pre></td></tr></table></figure>
<p>这些内容我写的还是比较简单，后续会进一步的完善。建议阅读官方文档<a href="https://note.youdao.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/ttl.html#per-queue-message-ttl</a>，或者上面提到的《RabbitMQ实战指南》,整个延迟队列的实现过程还是比较简单的，之后会把完整的代码贴出来。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/和喜欢的一切在一起/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/24/和喜欢的一切在一起/" class="post-title-link" itemprop="url">和喜欢的一切在一起</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-24 18:01:30" itemprop="dateCreated datePublished" datetime="2018-09-24T18:01:30+08:00">2018-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-23 19:30:43" itemprop="dateModified" datetime="2020-08-23T19:30:43+08:00">2020-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂书/" itemprop="url" rel="index"><span itemprop="name">杂书</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2018/09/24/和喜欢的一切在一起/like.jpg" alt="image"></p>
<ol>
<li>浮光再潋滟，淌不过流年。但纵使往事如烟，依然感谢你有缘在我生命中昙花一现。<br><br><br></li>
<li>这世界最美妙最浪漫的事就是做着自己喜欢的事还可以养活自己。<br><br><br></li>
<li>忘了谁说过，陪伴是最长情的告白。但我想说，守护使最沉默的陪伴。亲情，友情，爱情，但凡是感情想要长久都一样，就两句话：别听对方说什么，只看对方做什么；别在意对方没做什么，只在意对方付出了什么。这世上没人欠你什么，你也不欠别人什么，一切凭心。所谓珍惜，不是小心翼翼，而是自然反应。<br><br><br></li>
<li>也许故事没有那么多失忆，但柳暗花明的香味依旧最袭人。<br><br><br></li>
<li>北漂三年，最害怕行李箱的万向轮龇着地面时发出的哗啦。<br><br><br></li>
<li>但如果命运这么好掌握，那就不叫命运了<br><br><br></li>
<li>东西坏了，别想到丢，试试看能不能修。我们都一样，拥有的东西很少，别等到什么都没了，才学会哭。<br><br><br></li>
<li>活在一种看得见未来的生活里是很无趣的，尽管我知道每个人都有一个共同的结局是死亡，但如果我们活着的每一天都不能有所发现，没有未知和好奇，而只是机械地重复同样的事情，那等于我们已经死了。<br><br><br></li>
<li>在这个散乱的世界，每个人都在表达自己，却独独少了那位坐在对面,认真聆听，静静端详着你的听众。<br><br><br></li>
<li>许多人来来去去，相聚又别离。也有人匆匆逃离，这一个人的北京。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/hexo实现搜索-评论功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/image/image01.jpg">
      <meta itemprop="name" content="zhengwuhao">
      <meta itemprop="description" content="stay hungry stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WuHao">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/24/hexo实现搜索-评论功能/" class="post-title-link" itemprop="url">hexo实现搜索,评论功能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-24 14:04:18" itemprop="dateCreated datePublished" datetime="2018-09-24T14:04:18+08:00">2018-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-23 17:03:46" itemprop="dateModified" datetime="2020-08-23T17:03:46+08:00">2020-08-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo博客实现/" itemprop="url" rel="index"><span itemprop="name">hexo博客实现</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhengwuhao"
      src="/image/image01.jpg">
  <p class="site-author-name" itemprop="name">zhengwuhao</p>
  <div class="site-description" itemprop="description">stay hungry stay foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhengwuhao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
